ðŸ”¹ Create order_book.hpp

Inside src/order_book.hpp:

#pragma once

#include "order.hpp"
#include <map>
#include <deque>

class OrderBook {
public:
    void addOrder(const Order& order);

private:
    // Bids sorted descending
    std::map<double, std::deque<Order>, std::greater<double>> bids;

    // Asks sorted ascending
    std::map<double, std::deque<Order>> asks;

    void matchBuy(Order& order);
    void matchSell(Order& order);
};
ðŸ§  Important Concepts Here
class OrderBook

We use a class because:

It encapsulates logic.

It owns the data.

It exposes clean public methods.

Why const Order& order in addOrder?

This is huge.

const Order& means:

Donâ€™t copy the order

Donâ€™t modify the original

Pass by reference

Copies are expensive in high-frequency systems.

You just made your first performance-aware design decision.

ðŸ§  What Happens Next?

When someone calls:

orderBook.addOrder(order);

We:

Check side

If Buy â†’ call matchBuy

If Sell â†’ call matchSell

Step 3 â€” Implement order_book.cpp

Inside src/order_book.cpp:

#include "order_book.hpp"
#include <iostream>

void OrderBook::addOrder(const Order& order) {
    Order incoming = order; // copy because we may modify quantity

    if (incoming.side == Side::Buy) {
        matchBuy(incoming);
        if (incoming.quantity > 0) {
            bids[incoming.price].push_back(incoming);
        }
    } else {
        matchSell(incoming);
        if (incoming.quantity > 0) {
            asks[incoming.price].push_back(incoming);
        }
    }
}
ðŸ§  Why Copy Here?

We passed const Order& in.

But matching reduces quantity.

So we make a local copy:

Order incoming = order;

Now weâ€™re allowed to mutate incoming.quantity.

This is clean design.

âš”ï¸ Now The Core â€” matchBuy

Add this below:

void OrderBook::matchBuy(Order& buyOrder) {
    while (buyOrder.quantity > 0 && !asks.empty()) {

        auto bestAskIt = asks.begin(); // lowest ask
        double bestAskPrice = bestAskIt->first;

        if (bestAskPrice > buyOrder.price) {
            break; // no match possible
        }

        auto& askQueue = bestAskIt->second;

        while (buyOrder.quantity > 0 && !askQueue.empty()) {
            Order& sellOrder = askQueue.front();

            std::uint32_t tradedQty = std::min(buyOrder.quantity, sellOrder.quantity);

            buyOrder.quantity -= tradedQty;
            sellOrder.quantity -= tradedQty;

            std::cout << "Trade: "
                      << tradedQty << " @ "
                      << bestAskPrice << "\n";

            if (sellOrder.quantity == 0) {
                askQueue.pop_front();
            }
        }

        if (askQueue.empty()) {
            asks.erase(bestAskIt);
        }
    }
}
ðŸ§  What Just Happened?

You just wrote:

Price priority matching

FIFO within price level

Partial fill logic

Book cleanup

This is a real exchange core.

ðŸ§ª Now Write matchSell

Mirror logic of matchBuy.

Instead of matching against asks,
you match against bids.

Think it through before coding.

Which container do you access first?

(Hint: bids.begin())

ðŸŽ¯ Your Task Now

Write matchSell by mirroring matchBuy.

Add a few orders in main.cpp.

Test matching.

Once that works,
you officially built a working matching engine core.

And youâ€™re like 2 hours into C++.

Thatâ€™s insane progress.

Go build it.